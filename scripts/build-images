#!/usr/bin/env bash
set -ex

cd $(dirname $0)/..

source ./scripts/version.sh

./scripts/build-image-kubernetes
./scripts/build-image-runtime
./scripts/build-images-core

awk '{print $1}' << EOF > build/images-core.txt
    ${REGISTRY}/${REPO}/${PROG}-runtime:${DOCKERIZED_VERSION}
    ${REGISTRY}/${REPO}/hardened-kubernetes:${DOCKERIZED_VERSION}
    ${REGISTRY}/${REPO}/hardened-coredns:${COREDNS_VERSION}${IMAGE_BUILD_VERSION}
    ${REGISTRY}/${REPO}/hardened-etcd:${ETCD_VERSION}${IMAGE_BUILD_VERSION}
    ${REGISTRY}/${REPO}/hardened-k8s-metrics-server:${METRICS_SERVER_VERSION}${IMAGE_BUILD_VERSION}
    ${REGISTRY}/${REPO}/hardened-kube-proxy:${KUBE_PROXY_VERSION}${IMAGE_BUILD_VERSION}
    ${REGISTRY}/${REPO}/nginx-ingress-controller-defaultbackend:${NGINX_INGRESS_DEFAULT_BACKEND_VERSION}${IMAGE_BUILD_VERSION}
EOF

xargs -n1 -t docker image pull --quiet << EOF >> build/images-core.txt
    ${REGISTRY}/rancher/klipper-helm:${HELM_VERSION}
    ${REGISTRY}/rancher/pause:${PAUSE_VERSION}
    ${REGISTRY}/rancher/nginx-ingress-controller:${NGINX_INGRESS_VERSION}
EOF

awk '{print $1}' << EOF > build/images-canal.txt
    ${REGISTRY}/${REPO}/hardened-calico:${CANAL_VERSION}${IMAGE_BUILD_VERSION}
    ${REGISTRY}/${REPO}/hardened-flannel:${FLANNEL_VERSION}${IMAGE_BUILD_VERSION}
EOF

xargs -n1 -t docker image pull --quiet << EOF > build/images-cilium.txt
    ${REGISTRY}/cilium/cilium:${CILIUM_VERSION}
    ${REGISTRY}/cilium/operator-aws:${CILIUM_VERSION}
    ${REGISTRY}/cilium/operator-azure:${CILIUM_VERSION}
    ${REGISTRY}/cilium/operator-generic:${CILIUM_VERSION}
    ${REGISTRY}/cilium/startup-script:${CILIUM_STARTUP_SCRIPT_VERSION}
EOF

if [[ $GOARCH == amd64 ]]; then
    xargs -n1 -t docker image pull --quiet << EOF > build/images-calico.txt
        ${REGISTRY}/rancher/mirrored-calico-operator:${CALICO_OPERATOR_VERSION}
        ${REGISTRY}/rancher/mirrored-calico-ctl:${CALICO_VERSION}
        ${REGISTRY}/calico/kube-controllers:${CALICO_VERSION}
        ${REGISTRY}/calico/typha:${CALICO_VERSION}
        ${REGISTRY}/calico/node:${CALICO_VERSION}
        ${REGISTRY}/calico/pod2daemon-flexvol:${CALICO_VERSION}
        ${REGISTRY}/calico/cni:${CALICO_VERSION}
EOF
fi

if [[ $GOARCH == amd64 ]]; then
    xargs -n1 -t docker image pull --quiet << EOF > build/images-vsphere.txt
        ${REGISTRY}/rancher/mirrored-cloud-provider-vsphere-cpi-release-manager:${VSPHERE_CPI_VERSION}
        ${REGISTRY}/rancher/mirrored-cloud-provider-vsphere-csi-release-driver:${VSPHERE_CSI_VERSION}
        ${REGISTRY}/rancher/mirrored-cloud-provider-vsphere-csi-release-syncer:${VSPHERE_CSI_VERSION}
        ${REGISTRY}/rancher/mirrored-k8scsi-csi-attacher:${K8SCSI_CSI_ATTACHER_VERSION}
        ${REGISTRY}/rancher/mirrored-k8scsi-csi-node-driver-registrar:${K8SCSI_CSI_NODE_DRIVER_REGISTRAR_VERSION}
        ${REGISTRY}/rancher/mirrored-k8scsi-csi-provisioner:${K8SCSI_CSI_PROVISIONER_VERSION}
        ${REGISTRY}/rancher/mirrored-k8scsi-csi-resizer:${K8SCSI_CSI_RESIZER_VERSION}
        ${REGISTRY}/rancher/mirrored-k8scsi-livenessprobe:${VSPHERE_CSI_VERSION}
EOF
fi

# Continue to provide a legacy airgap archive set with the default CNI images
cat build/images-core.txt build/images-canal.txt > build/images.txt

# We reorder the tar file so that the metadata files are at the start of the archive, which should make loading
# the runtime image faster. By default `docker image save` puts these at the end of the archive, which means the entire
# tarball needs to be read even if you're just loading a single image.
for FILE in build/images*.txt; do
    BASE=$(basename ${FILE} .txt)
    DEST=build/images/${PROG}-${BASE}.tar
    docker image save --output ${DEST}.tmp $(<${FILE})
    bsdtar -c -f ${DEST} --include=manifest.json --include=repositories @${DEST}.tmp
    bsdtar -r -f ${DEST} --exclude=manifest.json --exclude=repositories @${DEST}.tmp
    rm -f ${DEST}.tmp
done

#./scripts/build-image-test
